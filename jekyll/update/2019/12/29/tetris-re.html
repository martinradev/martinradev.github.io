<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Write-up for hxp&#39;s tetres2019 challenge</title>
  <meta name="description" content="The gameThe game is tetris where, according to the rules, one has to score a lot of points to receive the flag.">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://yourdomain.com/jekyll/update/2019/12/29/tetris-re.html">
  <link rel="alternate" type="application/rss+xml" title="Martin's blog" href="http://yourdomain.com/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Martin's blog</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Write-up for hxp's tetres2019 challenge</h1>
    <p class="post-meta"><time datetime="2019-12-29T00:00:00+01:00" itemprop="datePublished">Dec 29, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h3 id="the-game">The game</h3>
<p>The game is tetris where, according to the rules, one has to score a lot of points to receive the flag.</p>

<p><img src="/assets/game.png" alt="Tetris game" class="center-image" /></p>

<p>The game doesn’t really give good figures to be able to score easily, the target score is not disclosed and since this is a reverse engineering challenge, it’s probably be best to go in the direction of reversing the game.</p>

<p>The challenge explicitly mentions that OpenGL 4.6 is required and that it only works on NVIDIA and Intel GPUs, so it would be best to look at the game in a graphics debugger.</p>

<h3 id="graphics-debugger">Graphics debugger</h3>
<p>I used RenderDoc as a graphics debugger to see what OpenGL calls are made and what the main rendering loop looks like.</p>

<p><img src="/assets/gl_calls.jpg" alt="GL calls" class="center-image" /></p>

<p>We can see that there are only two GL calls which make something useful: glDispatchCompute and glDrawArrays.
glDispatchCompute schedules a compute program to be executed and glDrawArrays schedules some primitives to be rendered.</p>

<p>We can also view resources in the game like textures, shaders and the whole GL state.</p>

<p><img src="/assets/gl_resources.jpg" alt="Resources" class="center-image" /></p>

<p>By examining the compute shader, we can deduce that all of the game logic happens in it.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>layout(set = 0, binding = 0, std430) coherent buffer State
{
    int arr[512];
} _35;

layout(set = 0, binding = 1, std430) coherent buffer State2
{
    int arr2[512];
} _234;

layout(set = 0, binding = 3, std430) buffer MyBlock
{
    int x;
    int y;
    int tetris;
    int dirx;
    int diry;
    int tock;
    int mhm;
    int idid;
} _279;

layout(set = 0, binding = 2, std430) coherent buffer Meta
{
    int gen;
    int abra;
    int chch;
    int chacha;
    uint d[32];
} _299;
</code></pre></div></div>

<p>The <code class="highlighter-rouge">_35</code>, <code class="highlighter-rouge">_234</code>, <code class="highlighter-rouge">_279</code> and <code class="highlighter-rouge">_299</code> buffers contain state information and are used throughout the whole program.
In particular, the <code class="highlighter-rouge">Meta::d[32]</code> buffer is used in the following snippet where it looks like something is being decoded:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if ((uint(lowest) == row) &amp;&amp; (row != 0u))
    {
        uint q = _299.d[(col + uint(_299.abra)) % 32u];
        q ^= (uint(_299.abra) + col);
        _299.d[(col + uint(_299.abra)) % 32u] = (q &lt;&lt; uint(25)) | (q &gt;&gt; uint(10));
        q = _299.d[((col + uint(_299.abra)) + 16u) % 32u];
        q ^= ((uint(_299.abra) + col) + 16u);
        _299.d[((col + uint(_299.abra)) + 16u) % 32u] = (q &lt;&lt; uint(25)) | (q &gt;&gt; uint(10));
    }
</code></pre></div></div>
<p>And the <code class="highlighter-rouge">_299.abra</code> variable keeps the score and is being incremented in a previous location in code:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ((uint(lowest) == row) &amp;&amp; (row != 0u))
{
        if ((col != 0u) &amp;&amp; (col != 15u))
        {
            for (int r = int(row); r &lt; 32; r++)
            {
                _234.arr2[(r * 16) + int(col)] = _35.arr[((r + 1) * 16) + int(col)];
                _35.arr[(r * 16) + int(col)] = _35.arr[((r + 1) * 16) + int(col)];
            }
        }
        if (col == 0u)
        {
            _299.abra++;
        }
    }
}
</code></pre></div></div>

<p>We can also see what GL calls were used to create the compute shader which will become important later:
<img src="/assets/gl_specialize_shader.jpg" alt="SPIR-V calls" class="center-image" />
<code class="highlighter-rouge">glShaderBinary</code> loads a binary file in a particular format and in this case it is in the SPIR-V format which was originally created to be used for the Vulkan API.
<code class="highlighter-rouge">glSpecializeShader</code> is used to change constants and specify an entry point. For this shader it only specifies the <code class="highlighter-rouge">main()</code> entry point.</p>

<p>Other than that there isn’t much else interesting in the compute shader. Everything else is logic for moving blocks and collision detection.</p>

<p>Next we examine the vertex and fragment shader used for rendering.
The vertex shader doesn’t do much but generate four vertices to create a rectangle to render to. This is a standard hacky way for creating a surface to render onto.
The fragment shader is fairly large but contains a lot of repetitive code.
The same GPU buffers persist in the fragment shader which means that they are shared with the compute shader.
There are a lot of arrays with indices which are used to compute coordinates in a texture.</p>

<p>The arrays:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int msg[5] = { 86, 56, 71, 37, 51 };
int msg_hoho[5] = {
	get_num(s, 10000), get_num(s, 1000), get_num(s, 100), get_num(s, 10), get_num(s, 1) };
int over[9] = { 93, 83, 59, 51, 0, 72, 53, 51, 37 };
int controls[9] = { 95, 71, 91, 49, 37, 71, 44, 75, 40 };
int controls_cmd[10] = { 25, 75, 51, 0, 83, 37, 37, 71, 26, 75 };
int rules[6] = { 81, 25, 44, 51, 75, 40 };
int rules3[10] = { 63, 44, 83, 87, 0, 26, 51, 44, 44, 118 };
</code></pre></div></div>

<p>The texture:
<img src="/assets/texture_atlas.jpg" alt="Texture atlas" class="center-image" /></p>

<p>This is the check used for checking for the win condition and rendering the flag onto screen.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (hoho == mhm) {
	startx = 0.03f;
	starty = .35;
	deltax = .029;
	deltay = .06;
	if (UV.x &gt; startx &amp;&amp; UV.x &lt; startx + 32. * deltax &amp;&amp; UV.y &gt; starty &amp;&amp; UV.y &lt; starty + deltay) {
		int i = int((UV.x - startx) / deltax);
		float fi = float(i);
		int q = int(d[i] ^ mhm2.x ^ mhm2.y);
		int qy = q / 11;
		q %= 11;
		float cx = tux * float(q) + (UV.x - (startx + deltax * float(fi))) * tux / deltax;
		float cy = tuy * float(qy) + ((UV.y - starty) * tuy / deltay);
		float r = texture(tex2, vec2(cx, cy)).r;
		color = mix(vec4(r) * vec4(sin(tock*.1 + uv.y), cos(tock*3 + uv.x), .0, 1.), color, 1. - r);
	}
	deltax = 0.025;
	deltay = 0.05;
}
</code></pre></div></div>
<p>The snippet computes the index in the text atlas with <code class="highlighter-rouge">int(d[i] ^ mhm2.x ^ mhm2.y</code>` and then renders it.</p>

<p>In fact we can edit the shaders in RenderDoc to see what happens.
Let’s change the if condition to always evaluate to true and modify the index computation to be <code class="highlighter-rouge">int((d[i] ^ mhm2.x ^ mhm2.y) &amp; 0xFF)</code> and then we get:</p>

<p><img src="/assets/broken_flag.jpg" alt="Broken flag" class="center-image" /></p>

<p>It’s some broken text but at least we learn that we should get the flag printed in the middle when we reach a win condition.
The win value is contained in the <code class="highlighter-rouge">mhm</code> uniform and its value is set to <strong>1337</strong>.
So, the player has to get a score of 1337 to get the flag.</p>

<p>Furthermore, there are the two values <code class="highlighter-rouge">mhm2.x</code> and <code class="highlighter-rouge">mhm2.y</code> with which the index is xor-ed.
Inspecting the values does not reveal anything but they seem to be some large xor masks, correspondingly <strong>0x71272A0A</strong> and <strong>0x60ABD0BD</strong>.
The two values will be relevant later.</p>

<p>Also, the <code class="highlighter-rouge">d[]</code> array being accesses is the same as the one to which it is written in the compute shader.
This reveals the whole way the flag is generated. Each time the player scores, the <code class="highlighter-rouge">d[]</code> array gets updated. Once a score of 1337 is reached, the fragment shader computes the indices in the text atlas using the <code class="highlighter-rouge">d[]</code> array and the two values in the <code class="highlighter-rouge">mhm2</code> vector.</p>

<p>We can try to get the flag by again modifying the shader to reach this condition.
First we remove the early <code class="highlighter-rouge">return</code> in the compute shader even if the game is over.
Then, we rewrite the code for incrementing the score and decoding the flag to:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (int i = 0; i &lt; 1337; ++i) {
    if (row == 0)
    {
        if ((col != 0u) &amp;&amp; (col != 15u))
        {
            for (int r = int(row); r &lt; 32; r++)
            {
                _234.arr2[(r * 16) + int(col)] = _35.arr[((r + 1) * 16) + int(col)];
                _35.arr[(r * 16) + int(col)] = _35.arr[((r + 1) * 16) + int(col)];
            }
        }
        if (col == 0u)
        {
            _299.abra++;
        }
    }
    memoryBarrierShared();
    barrier();
    if (row == 0)
    {
        uint q = _299.d[(col + uint(_299.abra)) % 32u];
        q ^= (uint(_299.abra) + col);
        _299.d[(col + uint(_299.abra)) % 32u] = (q &lt;&lt; uint(25)) | (q &gt;&gt; uint(10));
        q = _299.d[((col + uint(_299.abra)) + 16u) % 32u];
        q ^= ((uint(_299.abra) + col) + 16u);
        _299.d[((col + uint(_299.abra)) + 16u) % 32u] = (q &lt;&lt; uint(25)) | (q &gt;&gt; uint(10));
    }
    memoryBarrierShared();
    barrier();
}
</code></pre></div></div>

<p>We save by clicking F5 and then re-run the captured frame by clicking Tools -&gt; Start Replay Loop.
And then we get a broken flag again:</p>

<p><img src="/assets/broken_flag2.jpg" alt="Broken flag 2" class="center-image" /></p>

<p>It looks like there might be something else happening, so we have to examine the binary.</p>

<h3 id="assembly-debugger">Assembly debugger</h3>
<p>If we open the executable in pebear, then we can see that there is only one section named <code class="highlighter-rouge">peippo</code> and that the only two imports are <code class="highlighter-rouge">LoadLibraryA</code> and <code class="highlighter-rouge">GetProcAddress</code>. That’s not very helpful.</p>

<p>By opening it in x32dbg we can examine it and observe that in fact the game is packed using an unknown custom packer.
The CFG is the following:
<img src="/assets/packed_graph.jpg" alt="CFG depacker" class="center-image" /></p>

<p>If we just set a breakpoint on the last jmp instruction and reach it, we can see that the graph was altered after unpacking:
<img src="/assets/unpacked_graph.jpg" alt="CFG unpacked" class="center-image" /></p>

<p>I find it useful to step-through the execution of the program in the CFG.
Eventually we reach our first anti-debugger check which reads the PEB::BeingDebugged byte and sets the result at address 0x424FD4.
<img src="/assets/first_anti_debug.jpg" alt="Anti-debug PEB BeingDebugged" class="center-image" /></p>

<p>We can continue stepping-through and we reach another anti-debugger check which queries the running processes, computes a hash of their names and compares them against known hashes.
<img src="/assets/second_anti_debug.jpg" alt="Anti-debug process name hashes" class="center-image" />
This anti-debug check is bad since it can give false positives and also makes the game unwinnable if the player happens to have processes which happen to collide with the hashes.
but it’s easy to verify that some debuggers like OllyDbg, x32dbg and RenderDoc are detected via it in a sneaky way without making any strings present.
The check sets the value at 0x424488 to 1 if a debugger process is running.</p>

<p>After setting “Hardware break points” on the addresses 0x424488 and 0x424FD4, we eventually reach the places where the values are used.
<img src="/assets/update_byte_if_no_debugger.jpg" alt="Set byte to 7" class="center-image" /></p>

<p><img src="/assets/update_byte_if_no_process.jpg" alt="Set byte to 25" class="center-image" />
One of the values is set if no debugger is attached and the other one if no debugger process is running.</p>

<p>To find out the intention of setting these bytes only under these conditions we have to continue stepping through the program.
If we continue examining resources, we can see the text atlas being unpacked and loaded into a GL texture but that’s not where the bytes are being written.</p>

<p>Let’s examine the shaders and shader binary which are used. Unfortunately, since the exported GL functions depend on context initialization, the driver does not statically export them and thus we cannot find it using x32dbg at least in the list of exported functions in the nvogl32.dll (NVIDIA user-space GL driver).
But we can search for the function strings which are passed to <code class="highlighter-rouge">wglGetProcAddress</code> and set hardware break points.
Eventually we find out that the written bytes above are targetting the SPIR-V binary.</p>

<p>We can run the program twice: once with debugger attached and running, and once with both values unset by us.
Then we can dump both SPIR-V binaries, decompile them using any of the Khronos tools and compare them:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>266c266
&lt;         _299.d[(col + uint(_299.abra)) % 32u] = (q &lt;&lt; uint(13)) | (q &gt;&gt; uint(10));
---
&gt;         _299.d[(col + uint(_299.abra)) % 32u] = (q &lt;&lt; uint(25)) | (q &gt;&gt; uint(7));
269c269
&lt;         _299.d[((col + uint(_299.abra)) + 16u) % 32u] = (q &lt;&lt; uint(13)) | (q &gt;&gt; uint(10));
---
&gt;         _299.d[((col + uint(_299.abra)) + 16u) % 32u] = (q &lt;&lt; uint(25)) | (q &gt;&gt; uint(7));
</code></pre></div></div>
<p>So, so apparently we were working with the unmodified shader in RenderDoc.</p>

<p>Furthermore, the contents of the fragment shader and the spirv binary are used to compute the two hash values with which the text atlas indices are xor-ed when displaying the flag:
<img src="/assets/compute_hash.jpg" alt="Compute hash" class="center-image" />
The two values with the anti-debugger checks disabled are: 0x71272A0A and 0x515ECC80.</p>

<p>We can continue investigating and notice that we enter the game loop and that there are no more sneaky checks any longer.
With this we can move to the actual solution.</p>

<h3 id="dynamic-solution-in-renderdoc">Dynamic solution in RenderDoc</h3>
<p>A dynamic solution in RenderDoc would be easy since the debugger provides us with an easy interface for editing shaders and reloading them from a fixed state.</p>

<p>First we modify the compute shader to increase the score 1337 times and to apply each iteration of the rotation hash:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (int i = 0; i &lt; 1337; ++i) {
	if (row == 0)
	{
		if ((col != 0u) &amp;&amp; (col != 15u))
		{
			for (int r = int(row); r &lt; 32; r++)
			{
				_234.arr2[(r * 16) + int(col)] = _35.arr[((r + 1) * 16) + int(col)];
				_35.arr[(r * 16) + int(col)] = _35.arr[((r + 1) * 16) + int(col)];
			}
		}
		if (col == 0u)
		{
			_299.abra++;
		}
	}
	memoryBarrierShared();
	barrier();
	if (row == 0)
	{
		uint q = _299.d[(col + uint(_299.abra)) % 32u];
		q ^= (uint(_299.abra) + col);
		_299.d[(col + uint(_299.abra)) % 32u] = (q &lt;&lt; uint(25)) | (q &gt;&gt; uint(7));
		q = _299.d[((col + uint(_299.abra)) + 16u) % 32u];
		q ^= ((uint(_299.abra) + col) + 16u);
		_299.d[((col + uint(_299.abra)) + 16u) % 32u] = (q &lt;&lt; uint(25)) | (q &gt;&gt; uint(7));
	}
	memoryBarrierShared();
	barrier();
}
</code></pre></div></div>

<p>Next we edit the fragment shader to use the correct shader hashes:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (hoho == mhm) {
	startx = 0.03f;
	starty = .35;
	deltax = .029;
	deltay = .06;
	if (UV.x &gt; startx &amp;&amp; UV.x &lt; startx + 32. * deltax &amp;&amp; UV.y &gt; starty &amp;&amp; UV.y &lt; starty + deltay) {
		int i = int((UV.x - startx) / deltax);
		float fi = float(i);
		int q = int(d[i] ^ 0x71272A0A ^ 0x515ECC80);
		int qy = q / 11;
		q %= 11;
		float cx = tux * float(q) + (UV.x - (startx + deltax * float(fi))) * tux / deltax;
		float cy = tuy * float(qy) + ((UV.y - starty) * tuy / deltay);
		float r = texture(tex2, vec2(cx, cy)).r;
		color = mix(vec4(r), color, 1. - r);
	}
	deltax = 0.025;
	deltay = 0.05;
}
</code></pre></div></div>

<p>Remember to click the Refresh button in RenderDoc for both shaders, then go to Tools -&gt; Start replay loop and there you go:
<img src="/assets/dynamic_flag.jpg" alt="The real flag" class="center-image" /></p>

<h3 id="a-static-solution">A static solution</h3>
<p>Solving the challenge is also possible without a graphics debugger but it requires one to extract the text atlas, shaders and spirv binary. All of that can be done with the earlier steps but it might be a bit more difficult to analyze and experiment with.</p>

<p>Decompiling the SPIR-V binary can be done with SPIRV-Cross which outputs a GLSL shader.
In fact RenderDoc uses that tool internally to decompile the SPIR-V binary.</p>

<p>After extracting all of the shaders and GPU buffers, one can write a decoder:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h1=0x71272a0a
h2=0x515ecc80
bt = [
0x34EDC49F, 0x16ACC9CF, 0x705071FF, 0x5370F9EF,
0x14BAC19F, 0x36F8C9DB, 0x50357BEB, 0x726F73FB,
0x85348B0A, 0xE746831F, 0x81BA198F, 0xA3C8419F,
0x4C8FF9EF, 0x3ACD71FF, 0x5C3D69E5, 0x7E48F4F5,
0xA7FB8D06, 0x80CB0516, 0x46331D24, 0x64769464,
0x8BA38414, 0xA9958C04, 0xE5499434, 0xC7309C31,
0x3AE76E40, 0x18BF2650, 0x7CD73E60, 0x16BF3671,
0xF9678EA5, 0xDB24D4B5, 0xBDD94C85, 0x8B01C495]

target=1337
for u in range(target):
    for v in range(32):
        q = (u+1+v) ^ bt[(u+1+v)%32]
        bt[(u+1+v)%32] = ((q&lt;&lt;25)&amp;0xFFFFFFFF) | (q&gt;&gt;7)
for u in range(32):
    bt[u] = bt[u] ^ h1 ^ h2

text_map = {}
text_map[(6,3)] = "h"
text_map[(7,1)] = "x"
text_map[(8,3)] = "n"
text_map[(5,10)] = "{"
text_map[(9,7)] = "3"
text_map[(9,4)] = "0"
text_map[(3,8)] = "p"
text_map[(10,2)] = "$"
text_map[(4,4)] = "_"
text_map[(8,5)] = "G"
text_map[(5,8)] = "P"
text_map[(7,3)] = "U"
text_map[(5,5)] = "F"
text_map[(6,5)] = "o"
text_map[(3,4)] = "r"
text_map[(8,0)] = "7"
text_map[(4,7)] = "e"
text_map[(4,5)] = "t"
text_map[(9,5)] = "1"
text_map[(6,9)] = "s"
text_map[(9,6)] = "2"
text_map[(8,2)] = "9"
text_map[(8,10)] = "}"

flag = ""
for u in range(32):
    row = int(bt[u] / 11)
    col = bt[u] % 11
    if (row, col) not in text_map:
        print("{},{} not found in text_map".format(row,col))
        flag = flag + "?"
    else:
        flag += text_map[(row, col)]
print(flag)
</code></pre></div></div>

<p>Note that the <code class="highlighter-rouge">text_map</code> dictionary has entries only for what’s queried from the text atlas.</p>

<p>The script prints out the flag:
<code class="highlighter-rouge">hxp{300$_GPU_For_7etr1s_1n_2019}</code></p>

<h3 id="the-story-behind-the-challenge">The story behind the challenge</h3>
<p>At some point during the CTF preparation there was a shortage of RE challenges, so after a bump into <code class="highlighter-rouge">kirschju</code> we agreed that I can contribute with something small.
The challenge was really supposed to be a filler for the RE category and be developed using whatever tools I had left from my demoscene days.</p>

<p>The initial version was built was on top of the <a href="http://www.lofibucket.com/articles/64k_intro.html">Macau Exports 64k tool</a> and used <a href="https://martinradev.github.io/jekyll/update/2019/05/29/writing-a-pe32-x86-exe-packer.html">my packer</a> to get the binary small and also thwart static analysis and patching without at least running it.
Eventually I switched to <a href="https://github.com/msqrt/glsl-testbench">another framework</a> for creating the challenge since the original 64k tool was going at great lengths to keep the binary small and the code base was spaghetti.</p>

<p>We ran into multiple issues during the development phase:</p>
<ul>
  <li>For some reason the game does not run on AMD when the SPIR-V binary is used instead of plain GLSL.</li>
  <li>For some reasons GLSL’s atomicMin does not work on Intel and the Intel compiler does not complain. Maybe it’s an issue coming from the SPIR-V translation.
The fix was to rewrite the code to use a min-reduction.</li>
  <li>The NVIDIA user-space driver used to corrupt its heap once glSpecializeShader was called. That could be a bug coming from me.</li>
</ul>

<p>I hope the challenge was enjoyable and did not cause much frustration for those who were not able to run it.</p>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Martin's blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Martin's blog</li>
          <li><a href="mailto:martin.b.radev@gmail.com">martin.b.radev@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/martinradev"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">martinradev</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/martin_b_radev"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">martin_b_radev</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
