<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Writing an executable packer for Win32</title>
  <meta name="description" content="A very short introduction to 64k demosThe demoscene features various demo competitions for modern systems. The most notable categories are PC demo, 64k intro...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://yourdomain.com/jekyll/update/2019/05/29/writing-a-pe32-x86-exe-packer.html">
  <link rel="alternate" type="application/rss+xml" title="Martin's blog" href="http://yourdomain.com/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Martin's blog</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Writing an executable packer for Win32</h1>
    <p class="post-meta"><time datetime="2019-05-29T00:00:00+02:00" itemprop="datePublished">May 29, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h3 id="a-very-short-introduction-to-64k-demos">A very short introduction to 64k demos</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Demoscene">demoscene</a> features various demo competitions for modern systems. The most notable categories are <strong>PC demo</strong>, <a href="https://en.wikipedia.org/wiki/64K_intro">64k intro</a> and <strong>4k intro</strong>.</p>

<p>For me, the followng two reasons have made me prefer 64k demos:</p>
<ul>
  <li>it opens opportunities to implement a complex lighting solution, include interesting geometry, have multiple layers of post-processing.</li>
  <li>it keeps professional tools out for the most part, thus leaving technical problems for the group to solve.</li>
</ul>

<h3 id="what-goes-into-a-64kb-exe">What goes into a 64kb exe?</h3>
<p>The minimum the program has to do is open a window, create a rendering context and setup a graphics pipeline. Depending on the rendering choices it might happen that geometry and textures are generated on the CPU and that there are many and complex rendering paths. This contributes to a fairly big code section.</p>

<p>More and more of the work has been pushed onto the GPU which is programmed through shaders. They are often stored in plain GLSL source code or D3D shader bytecode.</p>

<p>A music synthesizer of some sort and note data which will contribute to both the code and data sections.</p>

<p>The rest is an overhead coming from the used executable format and the amount of imported functions.</p>

<p>Considering that a “Hello world” program is already close or above this limit, one can begin to worry in one’s success of developing a 64k intro.
It turns out, it can be <a href="http://www.lofibucket.com/articles/64k_intro.html">challenging but possible with some care and creativity</a>.</p>

<p>If we could somehow <strong>create a 200kb executable and compress it into a 64kb executable</strong>, we would likely have <strong>more to show than an ordinary 64kb executable.</strong></p>

<p>Here’s a distribution of the three biggest sections in the uncompressed executable for our old intro <a href="https://www.youtube.com/watch?v=yei3mJm33SQ">Guberniya</a>.</p>

<p><img src="/assets/packer_data/sect_distr.jpg" alt="Guberniya sections" class="center-image" /></p>

<p>So, it’s around 278 kb, most of which is data but not executable code.</p>

<p>To be able to enter the 64K category we would have to compress the executable in some way.</p>

<p>This is where a thing called an exe-packer comes into play.</p>

<h3 id="what-is-an-exe-packer">What is an exe-packer?</h3>
<p>An <a href="https://en.wikipedia.org/wiki/Executable_compression">executable packer</a> is a program which takes an <strong>Input program</strong> and outputs an <strong>Output program</strong> hopefully a lot smaller than the original one.
The output program is still a binary executable and no unpacking to disk is necessary. The reduction of size is achieved through compression.</p>

<p>The machine code and data of the original executable are compressed through the use of a suitable compression algorithm.
A small decompression stub becomes the entry point of the new program which will take the compressed data, decompress it somewhere in virtual memory, make some adjustments and jump into it to
start the execution of the original program.</p>

<p>Many of the size-limited demos make use of <a href="http://www.farbrausch.de/~fg/kkrunchy/">.kkrunchy</a> and <a href="https://in4k.github.io/wiki/crinkler">Crinkler</a>, correspondingly suited for 64KB and 4KB intros.</p>

<p>Almost all demo groups use them and both offer excellent compression rates and small decompression stubs.</p>

<h3 id="why-write-your-own-packer">Why write your own packer?</h3>
<p>It’s a cross of software engineering, low-level programming and science.</p>

<p>Working on the project wasn’t about improving over other solutions but rather about learning and improving my skills.
It helped me learn a lot more about data compression, how a PE32 binary looks like and a little bit about x86 assembly and its encoding.</p>

<h3 id="why-32-bit">Why 32-bit?</h3>
<p>I preferred keeping some comfort when working on the project. Typically, a 64-bit executable is bigger than a 32-bit one, thus some extra effort might have been necessary into making it all fit.
Compiled code for x86-64 will likely often include RIP-relative addressing which means that special care might be necessary to preprocess the data, so that it compresses better.
Also, our existing engine had been developed in the mindset that it would be running as a 32-bit exe, so there were likely some incompatibilities (or bugs) which we did not want to resolve.</p>

<h3 id="the-compressor">The compressor</h3>

<p>Before going into details of each step, let me give you an overview of the pipeline.</p>
<ul>
  <li>First we apply our domain knowledge to preprocess the data, so that it compresses better.</li>
  <li>We use LZ77 to compress the original data.</li>
  <li>We use a very simple adaptive 0-order model and arithmetic coder for the final pass.</li>
</ul>

<h4 id="lz77">LZ77</h4>

<p>I stopped at LZ77 for its simplicity and good results. However, there are multiple other benefits I did not consider at the beginning.</p>

<p>First, it is an asymmetric compressor. The compressor might run slow since it has to find a good way to parse and encode the input.
However, the decompressor is blazingly fast since it boils down to only memcopies and very few branches.</p>

<p>Second, in the <a href="http://www-math.mit.edu/~shor/PAM/lempel_ziv_notes.pdf">limit of the string S with length N, the average bits/byte reaches the entropy of the source H(S)/N</a>. Thus, with LZ77 we can still reach the absolute best we can do in terms of compression rate. The only issue is, of course, how fast we reach the limit.</p>

<p>LZ77 is really simple and the <a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77">wikipedia page explains it really well</a>. I will try to focus on the details of my implementation which helped me reach better results over time:</p>

<p>The three important parameters are the <strong>length</strong> and <strong>distance</strong> of references, and the minimum <strong>repetition length</strong> for which we would use a reference instead of directly copying the bytes into the output stream.</p>

<p>If the <strong>distance</strong> is too small, then we will not be able to use repetitions much earlier in the input. If too long, then we might be wasting bits in representing the distance.</p>

<p>If the <strong>length</strong> is too small, then we will not be able to handle very long repetitions with a single reference. If too big, again we will be wasting bits.</p>

<p>If the minimum repetition length is too small, then we will be wasting bits on encoding very short references.
If too long, we will be directly copying data which could have been encoded through references.</p>

<p>I ended up selecting the following configuration:</p>
<ul>
  <li><strong>Distance: 16 bits</strong>. We would like to be able to refer to data much earlier in the input.</li>
  <li><strong>Length: 8 bits</strong>. We do not expect to have very long repetitions. The length of a reference is thus at most 255.</li>
  <li><strong>Minimum repetition length</strong>: 3 bytes (24 bits). Repetitions of length 3 or less can directly be copied.</li>
  <li><strong>Type: 1 bit</strong>. We need it to disambiguate between references and direct copies.</li>
</ul>

<p><img src="/assets/packer_data/lz77.jpg" alt="LZ77" /></p>

<p>We can do a small optimization with respect to reference lengths.</p>

<p>If we are creating a reference, then we know that the repetition was bigger than 3. We can subtract (3+1) from the length of the repetition and use that instead. This adds the possibility to handle repetitions of 259 instead of the initial 255, thus saving some bytes potentially. This improved compression slightly.</p>

<h4 id="an-optimal-parser-assuming-no-entropy-coding">An optimal parser assuming no entropy coding</h4>
<p>We will be doing entropy coding afterwards, but let’s assume that we won’t. Thus the cost of a reference and direct copy will both be 25 bits.</p>

<p>How do we figure out when to use a reference and when to directly copy data, so that the total cost at the end is minimum?</p>

<p>We can try to design an algorithm linear in the input length using <a href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a>.
Let’s have an array <strong>best[]</strong> for which <strong>best[k]</strong> gives us the minimum cost for which we can parse the input <strong>from beginning till position k</strong>.
Suppose we have somehow computed the minimum costs for each position up to k. How can we update the value for position <strong>k+1</strong>?
Well, we can reach position <strong>k+1</strong> in multiple different ways:</p>
<ul>
  <li>Through a direct copy. Thus, from an earlier position we have copied 3 bytes and we have reached position k+1. This means that the cost would be <strong>best[k+1] = best[k-2] + 24 + 1 bits</strong>.</li>
  <li>Through a reference where the length could go from 4 to 259. Thus the cost would be <strong>best[k+1] = min(best[k-3], best[k-4], …, best[k-258]) + 24 + 1 bits</strong>.</li>
</ul>

<p>Since we can take either, the final cost becomes:</p>

<p><strong>best[k+1] = min(best[k-2], best[k-3], …, best[k-258]) + 24 + 1 bits</strong></p>

<p>At the beginning we set best[0] = 0 and best[1…N] to infinity. We process the array from left to right keeping track of the selection which gave us the best result.</p>

<p>Once we are done processing the array, we can go from end to beginning to recover whether a reference or a direct copy should be made.</p>

<h4 id="filtering-the-code-to-improve-compression">Filtering the code to improve compression</h4>

<p>When addresses of functions are known during compile/link time, relative calls are used - one because it allows the binary to be a PIE, and two because absolute calls would require having the address be first stored into a register or read from memory in the form of an indirect absolute call.
Thus, the majority of calls in our executable are relative calls. I measured that around <strong>10% of the bytes in .text section are for relative calls</strong> - 1 byte op-code and 4 bytes offset.</p>

<p>Because the calls are relative, the 4-byte offset will vary since the call is always done from a different position in memory. We can transform the relative-offset into an absolute address by adding the address of the opcode.
This guarantees that for every place where a given function is called, the op-code and now-transformed offset will match. That is a total of 5 bytes which will possibly repeat multiple times.
The technique is known as the <a href="http://mattmahoney.net/dc/dce.html#Section_571">E8-E9 filter</a> and more details can be found in this <a href="https://fgiesen.wordpress.com/2011/01/24/x86-code-compression-in-kkrunchy/">post by ryg</a>.</p>

<p>Applying the E8-E9 filter yielded around 10% improvement in compression ratio which is huge given its simplicity.</p>

<p>Later the filter was replaced with <a href="http://www.farbrausch.de/~fg/code/disfilter/">.kkrynchy’s disfilter</a>. There was an improvement of around 6% over the E8-E9 filter.</p>

<h4 id="arithmetic-coding">Arithmetic coding</h4>

<p>There wasn’t anything special with regards how the arithmetic coder was implemented. I just followed the slides from a <a href="https://courses.helsinki.fi/sites/default/files/course-material/4524672/DCT-lecture03.pdf">course I took in my B.S</a>.</p>

<h4 id="designing-a-model">Designing a model</h4>

<p>First some definitions:</p>

<p>The arithmetic coder needs to know the <strong>cumulative distribution</strong> of the symbols it has to encode/decode. For that we have to design a model which gives us a distribution which hopefully matches the actual distribution of the data we want to compress.</p>

<p>A <strong>static model</strong> is a model for which the probability of each symbol is pre-computed and stored. We cannot have a static model at all since the final binary has to be very small.</p>

<p>An <strong>adaptive model</strong> maintains the distribution of only the last K symbols. That distribution is likely closer to the distribution of the random variable which governs the next symbol in the stream.</p>

<p>I stopped at a <a href="https://www.cs.helsinki.fi/u/tpkarkka/opetus/12k/dct/lecture05.pdf">0-order</a> adaptive model. A 0-order context would mean the model does not consider what any of the previous characters are to estimate what the probability of next symbol should be.</p>

<p>There were some complications in designing a model:</p>
<ul>
  <li>When having an adaptive model, we run into the <a href="https://dl.acm.org/citation.cfm?id=2263404.2271157">zero frequency problem</a>. The solution, although bad, was to set the initial frequency of each symbol to 1. This means that we are paying a cost for symbols which might never occur.</li>
  <li>As mentioned before, the reference-distance is 16 bits. The distribution will be very sparse but we will still be paying due to the zero frequency problem.
Moreover, we want to be able to update the distribution fast by either decreasing or increasing the frequency of the symbol. And we need the cumulative probability of a symbol. Thus, if we update the frequency of a symbol at the beginning (and this will happen often since the reference distance will often be small), then we have to update all the subsequent ~2^16 elements. A possibility is to use a <a href="https://en.wikipedia.org/wiki/Fenwick_tree">Fenwick tree</a> but the implementation will be slightly bigger thus making the decompresor bigger.</li>
</ul>

<p>The solution was to split the 16-bit distance into two values - <strong>distance_low</strong> and <strong>distance_high</strong>. Each 8 bits.
This means two things:</p>
<ul>
  <li>The distributions of distance_low and distance_high will be less sparse and thus there would be less waste due to the 1 frequency initialization.</li>
  <li>Updates and queries can be done naively but still be fast enough.</li>
</ul>

<h4 id="optimal-parsing">“Optimal” parsing</h4>

<p>Yet another complication. Remember that optimal parser from before?</p>

<p>It’s not optimal with respect to the output of the entropy coder.
Why?</p>
<ul>
  <li>References will now likely no longer have a uniform cost of 25 bits. Some will be cheaper, some more costly. This would be the case with a static model as well.</li>
  <li>Copied bytes will also no longer cost 25 bits. This would be true also for a static model.</li>
  <li>We have an adaptive model, thus a choice at position <strong>i</strong> will change the distribution also effecting future choices.</li>
  <li>Even if we know how to get the lowest cost up to a position i, there could be <strong>exponentially many different paths</strong> to reach that position with that cost. Every path could define a different distribution of symbols. The parser would have to use the formed distributions up to this point to know the best way to reach i+1.</li>
</ul>

<p>So, we see it’s an issue which affects compression rate. We also see that it’s a computationally difficult problem. You can read <a href="http://cbloomrants.blogspot.com/2008/10/10-10-08-7_10.html">this article from Cbloom for more info</a>.</p>

<p>First, how do we compute the cost?</p>

<p>The entropy coder will output <strong>l</strong> number of bits per symbol where <strong>l</strong> depends on the probability <strong>p</strong> of that symbol.
It turns out that the <a href="https://en.wikipedia.org/wiki/Shannon%27s_source_coding_theorem">length <strong>l</strong> which minizes the average code word length is: <strong>l = -log2(p)</strong></a>. The arithmetic coder will encode each symbol with length very close to the optimal one.</p>

<ul>
  <li>The cost of a reference becomes: <strong>cost = -(log2(prob_distance_low) + log2(prob_distance_high) + log2(prob_length) + log2(prob_type_reference))</strong></li>
  <li>The cost of a direct copy becomes: <strong>cost = -(log2(prob_symb_0) + log2(prob_symb_1) + log2(prob_symb_2) + log2(prob_type_copy))</strong> where we also have to update the distribution after each of the symbols since we are using an adaptive model.</li>
</ul>

<p>Since it’s not clear which path is the best one and should be used, we can keep track of the <strong>first K-paths with the smallest cost to reach a given position</strong>.
So, we have the possibly best K-paths for each index from 0 to R, then to compute the best K-paths for R+1 we can do the following:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def computeBest(i):
{
    struct Selection
    {
        cost = INF
        distribution = Empty
    }
    K_MAX = 256 // Keep at most 256 'best' paths.
    bestSelection[i] = MinHeap(K_MAX) 
    // First try a reference
    for (j = 4; j &lt; WindowMaxLength &amp;&amp; j &lt;= i; ++j)
    {
        if canReach(from = i-j, to = i)
        {
            cost, distribution = computeRefCost(bestSelection[i-jj], i)
            bestSelection[i].insert(cost, distribution)
        }
    }
    // Now try to copy bytes
    cost, distribution = computeCopyCost(bestSelection[i-3])
    bestSelection[i].insert(cost, distribution)
}
</code></pre></div></div>

<p>This improved the compression rate significantly!</p>

<h3 id="finishing-the-packer">Finishing the packer</h3>
<p>As we have to generate our own executable, some knowledge of the PE32 format is necessary. The following two resources were enough to complete the packer.</p>
<ul>
  <li><a href="http://bytepointer.com/resources/pietrek_peering_inside_pe.htm">Peering Inside the PE: A Tour of the Win32 Portable Executable File Format, Matt Pietrek</a></li>
  <li><a href="http://sandsprite.com/CodeStuff/Understanding_imports.html">Understanding the Import Address Table</a></li>
</ul>

<h4 id="duties-of-the-packer-and-depacker">Duties of the packer and depacker</h4>
<p>Using our compressor we can compress all of the <strong>sections of the original exe</strong>.
Our decompressor stub will be the first thing executed in the new program.
In order to guarantee that the new program produces the same output as the original, the depacker has the following duties:</p>
<ul>
  <li>It should decompress the sections into the correct places in memory.
We can figure out the correct addresses from the <strong>ImageBase</strong> field and each section’s relative <strong>VirtualAddress</strong> field.</li>
  <li>It should handle imports. Since all of the sections of the original exe are compressed, the program loader would not know which are the imported libraries and functions.
It becomes our responsibility to populate the <strong>Import Address Table</strong>.</li>
  <li>It should undo the code filter.</li>
  <li>Jump into memory where the original exe’s entry point is.</li>
</ul>

<h4 id="a-one-section-exe">A one-section exe</h4>
<p>The new program will have exactly one big section. This potentially saves space as there are requirements on the alignment of each section in the file - 512 bytes. We also do not need more than one.</p>

<p><img src="/assets/packer_data/mem.jpg" alt="One big section" /></p>

<p>Since this one section serves for data and code, we will require that it’s mapped with <strong>MEM_EXECUTE, MEM_READ and MEM_WRITE characteristic flags</strong> set.
Since there are <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-_image_section_header">more possible characteristic flags</a> and I did not know what I was doing, I decided that it’s a safe bet to go over all sections and <strong>OR (|) the flags</strong>.
This worked but it might not have been necessary or erroneous.</p>

<p>Let’s say that all of the depacker is 0x1000 bytes long, that the uncompressed sections take 0xA1230 bytes, and that original ImageBase is 0x400000 (the default one).</p>

<p>Then we can have our new ImageBase as (0x400000-0x1000-0xA1230) &amp; ~(PAGE_SIZE-1). We zero-out the last couple of bits due to page-alignment requirements.
0x1000 is reserved for the depacker stub. We are left with 0xA1230 bytes for scratch memory to decompress all of the sections. We can subtract more if we need more scratch memory.</p>

<h4 id="handling-imports">Handling imports</h4>
<p>As mentioned we have to handle imports. To do so, we can import a single library - <strong>KERNEL32.DLL</strong> - and two functions - <strong>LoadLibraryA</strong> and <strong>GetProcAddress</strong>.
Our loader stub to handle imports can go over the Import Address Table (IAT), load the necessary libraries with LoadLibraryA and then call GetProcAddress to find the address of the functions necessary to import.
Then we can update each IAT entry with the virtual address of the corresponding function.</p>

<h4 id="removing-the-dos-stub">Removing the DOS stub</h4>
<p>Probably every PE32 article mentions that for legacy reasons many PE32 exes begin with a <a href="https://wiki.osdev.org/PE#DOS_Stub">DOS header and executable code</a>.
We have to keep the header, at least most of it. We can remove the executable code as it will only be executed under DOS.
This saves some bytes.</p>

<h4 id="better-utilization-of-padding">Better utilization of padding</h4>
<p>Each section needs to be 512 bytes aligned. This means that there is likely empty space added for alignment before the section. We can take advantage of that to store additional information.
There was around 192 bytes of unused space, so an optimization was to copy the last 192 bytes of the compressed data before the start of the section.
Then in our depacker we can include a couple of instructions (e.g. <strong>rep movsb</strong>) to append the “hidden bytes” to the back of the compressed data.</p>

<h4 id="handling-machine-code">Handling machine code</h4>
<p>We have to include into our new executable the pieces of machine code for copying data, decompressing data and handling imports.</p>

<p>I wrote everything in C and used <code class="highlighter-rouge">__declspec(noinline)</code> to prevent the compiler from inlining the functions of my interest.
I compiled using <strong>/Os</strong> to ask the compiler to produce smaller code if possible.</p>

<p>Then I used the Visual Studio debugger to get the machine code and instructions, copied them into a file and used a python script to generate a C byte-array which contains the machine code.
Then I would copy the C array of bytes into my packer.</p>

<p>It’s quite a cumbersome process. It would have been possible to use DUMPBIN and have a python script which does all of this automatically.</p>

<p>However, I did not have to go through the manual steps many times, so it wasn’t that bad.</p>

<h3 id="final-result">Final result</h3>

<iframe width="560" height="315" src="https://www.youtube.com/embed/bdb8G_DedpY" frameborder="0" allowfullscreen=""></iframe>

<p>You can also download the exe from the <a href="http://www.pouet.net/prod.php?which=77392">download link in pouet</a>. Note that it doesn’t work on AMD.</p>

<p>The uncompressed exe has a size of 165 KB.</p>

<p>The compressed exe has a size of 62.1 KB which also includes the depacker stub.</p>

<p>I recall that was slightly worse than 7-zip’s LZMA2 on maximum settings.</p>

<p>The demo was made with <a href="http://www.lofibucket.com/">cce</a> and <a href="https://www.pouet.net/user.php?who=53077">msqrt</a>.</p>

<h3 id="releasing-the-code-and-packer">Releasing the code and packer</h3>

<p>I’m not releasing the packer. I’m not releasing the source code.</p>

<p>Here are the reasons:</p>
<ul>
  <li>The packer is not on par with .kkrunchy or <a href="https://plot.ly/~yupferris/2//#/">Ferris’ squishy</a>, so there’s no use for it.</li>
  <li>The packer doesn’t handle TLS and likely has bugs.</li>
  <li>The source code is a mess.</li>
</ul>

<p>But if you have questions, write me an email :)</p>

<h3 id="acknowledgements">Acknowledgements</h3>

<p>Thanks to <a href="https://scholar.google.co.uk/citations?user=L5boL7MAAAAJ&amp;hl=da">Dmitry Kosolobov</a> for answering my questions in our coincidental bumps on the busses in Helsinki.</p>

<p>And thanks to <a href="https://www.cs.helsinki.fi/u/tpkarkka/">Juha Kärkkäinen</a> for the excellent course on data compression.</p>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Martin's blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Martin's blog</li>
          <li><a href="mailto:martin.b.radev@gmail.com">martin.b.radev@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/martinradev"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">martinradev</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/martin_b_radev"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">martin_b_radev</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
